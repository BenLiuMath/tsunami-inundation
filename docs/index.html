<!DOCTYPE HTML>
<html xml:lang="en" lang="en">
<head>
	<title>Tsunami Hazard Visualizer</title>
	<style>

	* { padding: 0; margin: 0; }

	body {
		margin: 0 auto 0 auto;
		padding: 0;
		max-width: 100%;
		font-family: "Avenir", "Avenir Next", Helvetica Neue, Arial;
		font-size: 0.95em;
	}
	
	.content {
		width:60%;
		min-width:800px;
		margin:0 auto;
	}

	h1, h2, h3, h4, h5 {
		color: #492a7c;
		background-color: inherit;
		font-weight: normal;
		padding: 0 0 5px 0;
		margin: 15px 0 0 0;
		border: none;
		clear: right;
	}
	h1 { font-size: 20pt; margin:  5px 0 10px 0; line-height: 28px; }
	h2 { font-size: 14pt; margin: 30px 0 15px 0; letter-spacing: 0.01em; border-bottom: 1px solid #ccc;  line-height: 20px;}
	h3 { font-size: 13pt; }
	h4 { font-size: 12pt; }
	h5 { font-size: 10pt; }
	p { margin: 0 0 10px 0; }

	#header {
		font-family: "Avenir Next";
		/* font-size: 1.8em; */
		padding: 10px;
	}

	#flipbookvis {
		position:relative;
		top:0;
		left:0;
		width:100%;
		height:500px;
		padding:0px;
		margin:0px;
		border: 1px solid #ccc;
	}
	#flipbookmap {
		position:absolute;
		top:0px;
		left:0px;
		width:100%;
		height:100%;
		display:block;
	}

	#viscontainer {
		position:relative;
		top:0;
		left:0;
		width:100%;
		height:600px;
		padding:0px;
		margin:0px;
	}

	#fieldtabs {
		margin:0px;
		height:40px;
		display:inline-block;
		z-index: 5; /* Brings buttons in front of map */
		background-color: #FFFFFF;
		text-align: center;
		overflow: hidden;
		border: 1px solid #ccc;
		background-color: #f1f1f1;
	}

	#tabbedcontent {
		position:relative;
		top:0px;
		left:0px;
		vertical-align: top;
		width:100%;
		height:calc(100% - 40px);
		//border: 1px solid #ccc;
	}
	#map {
		position:absolute;
		top:0px;
		left:0px;
		width:40%;
		height:calc(100% - 60px);
		display:block;
	}

	#slidecontainer {
		position: absolute;
		bottom:0px;
		left:2%;
		width:45%;
		z-index: 5; /* Brings slider in front of map */
	}

	.slider {
		width: 100%;
	}

	/*
	input[type=range]::-webkit-slider-runnable-track {
		width: 100%;
		height: 8.4px;
		cursor: pointer;
		box-shadow: 0px 0px 0px #000000, 0px 0px 0px #0d0d0d;
		background: rgb(211,211,211);
	}
	*/


	#individualfocus {
		position:absolute;
		top:0px;
		right:0%;
		width:60%;
		height:100%;
		display:block;
		padding:0;
		margin:0;
	}

	#smallmultiplescontainer {
		position:absolute;
		top:0;
		left:0;
		width:100%;
		height:100%;
	}

	#colorlegend {
		position:relative;
		top:-45px;
		left: 405px;
		width:550px;
		height:40px;
		background: rgb(255,255,255,.7);
		/* border:1px solid black; */
		display:inline-block;
	}

	#resetbutton {
	    position: absolute;
	    top:-38px;
	    left: 290px;
		width:80px;
	    z-index: 5; /* Brings buttons in front of map */
	    background-color: #FFFFFF;
	    text-align: center;
	    padding-left: 5px;
	}
	#resetbutton input {
		width:100%;
	}


	.SvgOverlay {
		position: relative;
		width: 100%;
		height: 100%;
	}
	.SvgOverlay svg {
		position: absolute;
		top: -4000px;
		left: -4000px;
		width: 8000px;
		height: 8000px;
		opacity: 1.0;
	}
	.SvgOverlay path {
		stroke: black;
		stroke-width: 0px;
		//fill-opacity: 0.3;
	}


	.backdrop {
		position:absolute; top:0px; left:0px;
		width:100%;
		height:100%;
		opacity:0.8;
	}

	.MapBounds {
		color:red;
	}

	.smallmultiple {
		margin:1% 1% 1% 1%;
		padding:0;
		width:30%;
		height:46%;
		border:1px solid black;
		display:inline-block;
	}

	.simLabel {
		padding-top:5px;
		height:1.5em;
		text-align:center;
		background: rgb(255,255,255,.5);
	}

	.smallMultipleMap {
		margin:none;
		display:block;
		width: 100%;
		height: calc(100% - 1.5em - 5px);
		padding: 0px;
	}


	#supplemental {
		position:relative;
		margin-top:150px;
		font-family: "Avenir Next";
		/* font-size: 1.8em; */
	}

</style>

<style>
/* Style the tab */


/* Style the buttons that are used to open the tab content */
#fieldtabs button {
    background-color: inherit;
    border: none;
    outline: none;
	margin:none;
    cursor: pointer;
	padding:0 1em 0 1em;
	height:100%;
    transition: 0.3s;
}

/* Change background color of buttons on hover */
#fieldtabs button:hover {
    background-color: #ddd;
}

/* Create an active/current tablink class */
#fieldtabs button.active {
    background-color: #ccc;
}
</style>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCyJ45cnv6HeZr69pu26XSsUF-OMC6cNRU"></script>
<script type="text/javascript" src="https://d3js.org/d3.v4.min.js" ></script>
<script src="https://d3js.org/d3-contour.v1.min.js"></script>
<script src="https://d3js.org/d3-hsv.v0.1.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.js"></script>

</head>
<body>
<div class="content">

	<div id="header">

		<h1>Estimating the Risks of Tsunamis</h1>

		<!-- <p>On the West Coast of the United States, these earthquakes come in two flavors.
			First, there are the earthquakes occuring in the <strong>Cascadia Subduction Zone</strong>, which are referred to as <strong>near-field</strong> events
			(since they occur relatively nearby). Near-field events have a limited geographic area in which they can occur, so they occur relatively frequently.
			Since they originate nearby, however, the tsunamis they trigger can be extremely damaging.</p>

			<p>The opposite of near-field events are <strong>far-field</strong> events. These can occur in a much broader range of locations, and hence are
				much more common. However, the greater distance of the West Coast from the earthquake's origin means that the resulting tsunamis often
			have less severe effects (on us, at least).</p>

				 <p>Let's look at an example: Crescent City, CA. </p>

				 <p><a href="https://en.wikipedia.org/wiki/Crescent_City,_California">Crescent City</a>
					 lies in the northenmost part of California, about 20 miles south of Oregon and along the coast.
					 It has a history of damage due to tsunamis, including the 1964 Alaska earthquakes and the 2011 Tohoku earthquake.
					 Several blocks of Crescent's City's downtown area were destroyed by the 1964 tsunami, and are now covered by
					 the Beach Front Park you see along the waterfront in the maps below.
				 </p> -->

		<!-- <p>Choose
			<a href="#supplemental">near-field</a>
			near-field
			</span>
			(Cascadia) or <a href="#supplemental">far-field</a> events.
			A single-click on the large map (aggregated inundation levels) will focus the small maps (corresponding to different simulations) on that spot.
		</p> -->

		<p>
		At 5:36 p.m. AST On March 27, 1964 600 miles of fault near Anchorage, Alaska ruptured, resulting in the second most powerful earthquake ever recorded. Roughly four hours later the first of four tsunami waves caused by the quake reached Crescent City, California. The first wave merely resulted in localized flooding. The second and third were smaller than the first and had little effect. The fourth wave, however, struck the city with a height of about six meters (20 feet) after having pulled most of the water from the harbor. After the dust had settled the damage was tallied: over 100 injured; 12 confirmed dead; 289 buildings destroyed; 100 cars and 25 large fishing ships crushed; 60 blocks inundated with 30 beyond repair.
		</p>

		<p>
		Due to its offshore geography, Crescent City, and especially its harbor, are unusually susceptible to tsunamis. Since 1964 the city has sustained damage from a number of additional earthquakes. The 2005 Eureka earthquake caused the entire city to be evacuated. In November 2006, an earthquake by the Kuril Islands in the western Pacific created a tsunami which damaged multiple docks and boats. The 9.0 earthquake that struck Japan on March 11, 2011 produced a tsunami which destroyed 35 boats and damaged the harbor severely.
		</p>

		<p>
		To estimate a community's risk of flooding due to a tsunami, researchers use numerical simulations. The process of modeling a tsunami begins with the specification of a slip pattern, which measures where and to what degree the ocean floor moves in during the earthquake. The slip pattern determines how water is displaced, leading to the initial formation of the tsunami. The displaced water is then tracked to determine the degree of inland flooding, known as inundation.
		</p>
		
	</div>

	<div id="flipbookvis">
		<div id="flipbookmap"></div>
	</div>

		<p>
		Notice that in (the flipbook animation), the simulated tsunamis have vastly different impacts on Crescent City in terms of flooding. In order to understand the “overall” tsunami risk posed to the city, we have to take into account the characteristics of each simulation.
		</p>
		
		<p>
		The tsunamis which affect Crescent City are caused by earthquakes that come in two types. First there are the earthquakes originating in the Cascadia Subduction Zone, which are referred to as near-field events (since they occur relatively nearby). Since near-field events have a limited geographic area in which they can occur they occur relatively infrequently. Since they originate nearby, however, the tsunamis they trigger can be extremely damaging.
		</p>
		
		<p>
		The opposite of near-field events are far-field events. These can occur in a much broader range of locations, and hence are much more common. However, the greater distance of the West Coast from the earthquake's origin means that the resulting tsunamis usually have less severe effects. The far-field events in our simulations come from Alaska and the Aleutian Islands, Southern Chile, Kamchatka, the Kuril Islands, and Tohoku, Japan.
		As described above, near- and far-field events differ in terms of how likely they are to occur. But individual simulations from the same (or similar) locations can also differ in how likely they are to occur, based on properties of the tectonic plates in that location.
		</p>
		
	<div id="viscontainer">
		<!-- Buttons for near- and far-field events -->
		<div id="fieldtabs">
			<button class="tablinks" id="switchEvents_near" value="near">Near-field</button>
			<button class="tablinks" id="switchEvents_far" value="far">Far-field</button>
			<button class="tablinks" id="switchEvents_both" value="both">Near- and Far-field</button>
		</div>
		<div id="tabbedcontent">
			<div id="map"></div>
			<div id="colorlegend"></div>
			<div id="individualfocus">
				<div class="backdrop"></div>
				<div id="smallmultiplescontainer"></div>
			</div>


			<!-- Button to reset view -->
			<div id="resetbutton">
				<input id="resetView" type="button" value="Reset View">
			</div>

			<!-- Slider for probability -->
			<div id="slidecontainer">
				<input type="range" min="0" max="6" step="1" class="slider" id="probabilitySlider" list="tickmark">
				<datalist id="tickmark">
					<option label="1/50">0</option>
					<option label="1/100">1</option>
					<option label="1/200">2</option>
					<option label="1/500">3</option>
					<option label="1/1000">4</option>
					<option label="1/5000">5</option>
					<option label="1/10000">6</option>
				</datalist>
				<output id="output" for="probabilitySlider">Selected annual probability: 1 in 500</output> <!-- Just to display selected value -->
			</div>
		</div>
	</div>

	<div id="supplemental">
		<h1>Supplemental</h1>
		<p> more things???? </p>
	</div>

</div>
<!-- Load in the simulation data and inundation maps -->
<script src="data/simulation_data.js"></script>
<script src="data/inundation_maps.js"></script>


<!-- Styled map specifications -->
<script>
var styledMapType = new google.maps.StyledMapType(
	[
  {
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#f5f5f5"
      }
    ]
  },
  {
    "elementType": "labels.icon",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#616161"
      }
    ]
  },
  {
    "elementType": "labels.text.stroke",
    "stylers": [
      {
        "color": "#f5f5f5"
      }
    ]
  },
  {
    "featureType": "administrative.land_parcel",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#bdbdbd"
      }
    ]
  },
  {
    "featureType": "poi",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#eeeeee"
      }
    ]
  },
  {
    "featureType": "poi",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#757575"
      }
    ]
  },
  {
    "featureType": "poi.park",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#e5e5e5"
      }
    ]
  },
  {
    "featureType": "poi.park",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#9e9e9e"
      }
    ]
  },
  {
    "featureType": "road",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#ffffff"
      }
    ]
  },
  {
    "featureType": "road.arterial",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#757575"
      }
    ]
  },
  {
    "featureType": "road.highway",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#dadada"
      }
    ]
  },
  {
    "featureType": "road.highway",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#616161"
      }
    ]
  },
  {
    "featureType": "road.local",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#9e9e9e"
      }
    ]
  },
  {
    "featureType": "transit.line",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#e5e5e5"
      }
    ]
  },
  {
    "featureType": "transit.station",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#eeeeee"
      }
    ]
  },
  {
    "featureType": "water",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#c9c9c9"
      }
    ]
  },
  {
    "featureType": "water",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#9e9e9e"
      }
    ]
  }
],{name: 'Styled Map'});
</script>

<!-- Make the map!  -->
<script>
	function shuffle(a) {
		var j, x, i;
		for (i = a.length - 1; i > 0; i--) {
			j = Math.floor(Math.random() * (i + 1));
			x = a[i];
			a[i] = a[j];
			a[j] = x;
		}
		return a;
	}
	function clamp(a,min,max) {
		return Math.min(Math.max(a,min),max);
	}

	var cityCenter = {'x':-124.2026, 'y':41.7558};
	var individualView = document.getElementById("individualfocus");

	var lng_low = 235.79781-360;
	var lng_high = 235.82087-360;
	var lat_low = 41.739671;
	var lat_high = 41.762726;


	var mults = []; // array of small multiples
	var markers = []; // array of markers currently on the maps

	// // Color scheme for the inundation levels
	// // var i0 = d3.interpolateHsvLong(d3.hsv(120, 1, 0.65), d3.hsv(10, 1, 0.90));
	// // var depthColors = d3.scaleSequential(i0).domain([0, 5]);
	var i0 = d3.interpolateCool;
	function interpolateReverse(t){
		return i0(1-t);   // assumes [0,1] range
	}
	var depthColors = d3.scaleSequential(interpolateReverse).domain([0,12]);
	var depthBins = [1.5,3.0,4.5,6.0,7.5,9.0,10.5,12.0];

	flipBookMain();
	function flipBookMain() {
		// google map background
		var map = new google.maps.Map(document.getElementById('flipbookmap'), {
			center: {lat:(cityCenter.y-0.005), lng:(cityCenter.x+.0125)},
			zoom: 14,
			// styles:[{"stylers": [{"lightness": 100}]}],
			styles:[
				{
					"featureType": "all",
					"stylers": [{"color": "#C0C0C0"}]
				}
			],
			scrollwheel: false,
			mapTypeControl: true,
			streetViewControl: false,
			fullscreenControl: false,
			mapTypeControlOptions: {
				//mapTypeIds: ['styled_map']
				mapTypeIds: []}
		});

		map.mapTypes.set('styled_map', styledMapType);
        map.setMapTypeId('styled_map');

		// overlay geojson multipolygons on map
		var overlay = new google.maps.OverlayView();

		var contourGroup, svg, pathproj, surfDataProjection;
		overlay.onAdd = function () {
			var layer = d3.select(this.getPanes().overlayMouseTarget)
				.append("div")
				.attr("class", "SvgOverlay");
			svg = layer.append("svg");
			contourGroup = svg.append("g")
				.attr("class", "contourGroup")
				.attr("opacity",.8);
			var overlayProjection = this.getProjection();

			// turn google map projection into d3 projection
			var googleMapProjection = d3.geoTransform({point: function(x, y) {
				d = overlayProjection.fromLatLngToDivPixel( new google.maps.LatLng(y, x) );
				this.stream.point(d.x + 4000, d.y + 4000);
			}});
			pathproj = d3.geoPath().projection(googleMapProjection);

			var surfData = {width:250, height:250};
            surfDataProjection = d3.geoTransform({point: function(i,j) {
                x = lng_low+j/surfData.width*(lng_high-lng_low);
                y = lat_low+i/surfData.height*(lat_high - lat_low);
				d = overlayProjection.fromLatLngToDivPixel( new google.maps.LatLng(y, x) );
				this.stream.point(d.x + 4000, d.y + 4000);
			}});
			
			flipBook();
			setInterval(flipBook, 3000);
		}
		overlay.setMap(map);

		overlay.draw = function () {
			this.update();
		}
		overlay.update = function() {
			svg.selectAll(".mypoly")
				.attr("d", d3.geoPath().projection(surfDataProjection) )
		}
		
		var tsunamiEvents = all_events;
		shuffle(tsunamiEvents);
		var flipInd = 0;
		function flipBook() {
			var surfData = tsunamiEvents[flipInd].eta_data;
			flipInd = (flipInd+1)%tsunamiEvents.length;
			
			var contourContainer = svg.append("g");
			contourContainer.attr("opacity",0)
				.transition()
				.ease(d3.easeSinInOut)
				.duration(500)
				.attr("opacity",0.8)
				.transition()
				.delay(2000)
				.ease(d3.easeSinInOut)
				.duration(500)
				.attr("opacity",0)
				.remove();
			
			contData = d3.contours()
					.size([surfData.width, surfData.height])
					.thresholds(depthBins)
					//.thresholds([1,2,3,4,5])
					(surfData.values);

			contourContainer.selectAll(".mypoly")
				.data(contData)
				.enter()
				.append("path")
				.attr("d", d3.geoPath().projection(surfDataProjection))
				.attr("class", "mypoly")
                .attr("fill", function(d) { return depthColors(d.value); });
		}
	}


	main();
	function main() {
		// initialize with near-field data
		var tsunamiEvents = near_events;
		var hazard_maps = eta_ps_near;

		// google map background
		var map = new google.maps.Map(document.getElementById('map'), {
			center: {lat:(cityCenter.y-0.005), lng:(cityCenter.x+.0125)},
			zoom: 14,
			// styles:[{"stylers": [{"lightness": 100}]}],
			styles:[
				{
					"featureType": "all",
					"stylers": [{"color": "#C0C0C0"}]
				}
			],
			scrollwheel: false,
			mapTypeControl: true,
			streetViewControl: false,
			fullscreenControl: false,
			mapTypeControlOptions: {
				//mapTypeIds: ['styled_map']
				mapTypeIds: []}
		});
		function focusArea(e) {
			//map.panTo(e.latLng);
			//map.setZoom(15);
			//latlngJSON = e.latLng.toJSON();
			var latLng = e.latLng.toJSON();
			
			var lat = latLng.lat;
			var lng = latLng.lng;
			//if (lat > lat_high || lat < lat_low || lng < lng_low || lng > lng_high) return;
			latLng.lat = clamp(lat,lat_low, lat_high);
			latLng.lng = clamp(lng,lng_low, lng_high);
			
			individualView.style.display = "block";
			panMultiples(latLng);
			deleteMarkers();
			addMarker(latLng, map);
			addMarkersMultiples(latLng);
          	// map.setCenter(marker.getPosition());
        }

		// zoom in and recenter when user clicks on a point
		map.addListener('click', focusArea);

		map.mapTypes.set('styled_map', styledMapType);
        map.setMapTypeId('styled_map');

		// overlay geojson multipolygons on map
		var overlay = new google.maps.OverlayView();

		var contourGroup, svg, pathproj, surfDataProjection;
		overlay.onAdd = function () {
			var layer = d3.select(this.getPanes().overlayMouseTarget)
				.append("div")
				.attr("class", "SvgOverlay");
			svg = layer.append("svg");
			contourGroup = svg.append("g")
				.attr("class", "contourGroup")
				.attr("opacity",.8);
			var overlayProjection = this.getProjection();

			// turn google map projection into d3 projection
			var googleMapProjection = d3.geoTransform({point: function(x, y) {
				d = overlayProjection.fromLatLngToDivPixel( new google.maps.LatLng(y, x) );
				this.stream.point(d.x + 4000, d.y + 4000);
			}});
			pathproj = d3.geoPath().projection(googleMapProjection);

			var surfData = {width:250, height:250};
            surfDataProjection = d3.geoTransform({point: function(i,j) {
                x = lng_low+j/surfData.width*(lng_high-lng_low);
                y = lat_low+i/surfData.height*(lat_high - lat_low);
				d = overlayProjection.fromLatLngToDivPixel( new google.maps.LatLng(y, x) );
				this.stream.point(d.x + 4000, d.y + 4000);
			}});
		}
		overlay.setMap(map);

		overlay.draw = function () {
			this.update();
		}
		overlay.update = function() {
			contourGroup.selectAll(".mypoly")
				.attr("d", d3.geoPath().projection(surfDataProjection) )
		}


		function switchEventType(ptype) {
			var i, tabcontent, tablinks;

			// Get all elements with class="tablinks" and remove the class "active"
			tablinks = document.getElementsByClassName("tablinks");
			for (i = 0; i < tablinks.length; i++) {
				tablinks[i].className = tablinks[i].className.replace(" active", "");
			}

			// Show the current tab, and add an "active" class to the button that opened the tab
			//evt.currentTarget.className += " active";
			document.getElementById("switchEvents_"+ptype).className += " active";

			switch(ptype) {
				case "far":
					tsunamiEvents = far_events;
					hazard_maps = eta_ps_far;
				break;
				case "near":
					tsunamiEvents = near_events;
					hazard_maps = eta_ps_near;
				break;
				default:
					tsunamiEvents = all_events;
					hazard_maps = eta_ps_all;
			}
			initPlots();
		}

		function attachButtons() {
			var types = ["near","far","both"];
			for(var ii=0; ii<types.length; ii++) {
				var mybutton = document.getElementById("switchEvents_"+types[ii]);
				function buttonfunc(evt) {
					switchEventType(evt.currentTarget.value);
				}
				mybutton.addEventListener("click",buttonfunc);
			}
		}
		attachButtons();

		document.getElementById("resetView")
			.addEventListener("click", function() {
				var resetLatLng = {lat:(cityCenter.y-0.005), lng:(cityCenter.x+.0125)};
				map.setCenter(resetLatLng);
				map.setZoom(14);
				deleteMarkers();
				panMultiples(resetLatLng,14);
			});


		function setContourData(surfData) {
			contData = d3.contours()
					.size([surfData.width, surfData.height])
					.thresholds(depthBins)
					//.thresholds([1,2,3,4,5])
					(surfData.values);

					contourGroup.selectAll(".mypoly")
				.attr("class","remove")
				.remove();
			contourGroup.selectAll(".mypoly")
				.data(contData)
				.enter()
				.append("path")
				.attr("d", d3.geoPath().projection(surfDataProjection))
				.attr("class", "mypoly")
                .attr("fill", function(d) { return depthColors(d.value); });
		}

		var yearlyRecurrences = [50,100,200,500,1000,5000,10000];
		// Set the contour data by specifying the yearly recurrence (inverse probability). Code searches for closest probability level to given parameter.
		function setProbLevel(yearlyRecurrence) {
			var bestind = 0;
			var closeness = 100000;
			for(var ii=0; ii<yearlyRecurrences.length; ii++) {
				var thisclose = Math.abs(yearlyRecurrences[ii]-yearlyRecurrence);
				if( Math.abs(thisclose) < closeness ) {
					bestind = ii;
					closeness = thisclose;
				}
			}
			setContourData(hazard_maps[bestind]);
		}
		function setProbLevelByIndex(ind) {
			setContourData(hazard_maps[ind]);
		}

		var outputSlider = document.getElementById("output");
		var probSlider = document.getElementById("probabilitySlider");
		probSlider.addEventListener("change",function() {
			setProbLevelByIndex(probSlider.value);
			outputSlider.value="Selected annual probability: 1 in " + pInv[probSlider.value];
		});


		function initPlots() {
			setProbLevel(1000);
			populateMultiples();
		}
		setTimeout(initPlots, 1000);

		// For drawing small multiples
		var multcontainer = document.getElementById("smallmultiplescontainer");

		for(var ii=0; ii<6; ii++) {
			var mymultDiv = document.createElement("div");
				mymultDiv.classList.add("smallmultiple");
				multcontainer.appendChild(mymultDiv);
			var mymult = multMaker(mymultDiv);
			mults.push(mymult);
		}

		function populateMultiples() {

			var eventshuffle = tsunamiEvents.slice();
			shuffle(eventshuffle);

			for(var ii=0; ii<Math.min(eventshuffle.length, 6); ii++ ) {
				//mults[ii].setGeojson(CSZEvents[ii]);
				mults[ii].setContourData(eventshuffle[ii].eta_data);
				mults[ii].setLabel(eventshuffle[ii].decode);
			}
		}

		function makeLegend() {
			// draw the legend
			var legWidth = 550;
			var legHeight = 40;

			var svg = d3.select("#colorlegend")
					.attr("class","legendQuant")
					.append("svg")
					.attr("width", legWidth)
					.attr("height", legHeight);

			svg.append("g")
			.attr("class", "legendSequential")
			.attr("transform", "translate(0,0)");

			svg.append("text")
			// .attr("class", "legendSequential")
			.attr("transform", "translate(440,33)")
			.text("meters flooded");

			/*
			// maybe rotate the text 90 degrees?
			svg.append("text")
			.attr("x", 345)
			.attr("y", 32)
			.text("Meters");
			*/

			var legendSequential = d3.legendColor()
				.shapeWidth(50)
				.shapePadding(0)
				.cells(9)
				.orient("horizontal")
				.labelAlign("start")
				// .title("Meters Flooded")
				// .titleWidth(100)
				.scale(depthColors);

			svg.select(".legendSequential")
				.attr("opacity",.8)
				.call(legendSequential);
		}
		makeLegend();
	}


function deleteMarkers() {
	for (var i = 0; i < markers.length; i++) {
			markers[i].setMap(null);
		}
		markers = [];
}

function addMarker(latLng, map) {
	// add the new marker to the given map
	var marker = new google.maps.Marker({
		position: latLng,
		map: map
	});
	// record the marker
	markers.push(marker);
}

function addMarkersMultiples(latLng) {
	for(var ii=0; ii<mults.length; ii++) {
		addMarker(latLng, mults[ii].map);
	}
}

function panMultiples(latLng,zoom) {
	if(!zoom) {
		zoom = 14;
	}
	for(var ii=0; ii<mults.length; ii++) {
		mults[ii].map.setZoom(zoom);
		mults[ii].map.panTo(latLng);
	}
}


function multMaker(containerDiv) {

	var mult = {};

	var myLabel = document.createElement("div");
		myLabel.classList.add("simLabel");
		//myLabel.appendChild(document.createTextNode("label"))
		myLabel.innerText = " ";
	containerDiv.appendChild(myLabel);

	var mapContainer = document.createElement("div");
	mapContainer.classList.add("smallMultipleMap");
	containerDiv.appendChild(mapContainer);
	mult.setLabel = function(text) {
		myLabel.innerText = text;
	}

	// google map background
	var map = new google.maps.Map(mapContainer, {
		// center: new google.maps.LatLng(47.4,-120.5),
		//center: new google.maps.LatLng(41.759671,-124.20219),
		center: {lat:41.7509671, lng:-124.19219},
		zoom: 14,
		disableDoubleClickZoom:true,
		draggable: false,
		scrollwheel: false,
		panControl: false,
		styles:[{"stylers": [{"lightness": 100}]}],
		mapTypeControl: false,
		streetViewControl: false,
		fullscreenControl: false,
		zoomControl:false,
		mapTypeControlOptions: {
			mapTypeIds: ['roadmap', 'styled_map']}
	});


	map.mapTypes.set('styled_map', styledMapType);
	map.setMapTypeId('styled_map');

	// overlay geojson multipolygons on map
	var overlay = new google.maps.OverlayView();

	var contourGroup, pathproj, svg, surfDataProjection;
	overlay.onAdd = function () {
		var layer = d3.select(this.getPanes().overlayMouseTarget)
			.append("div")
			.attr("class", "SvgOverlay");
		svg = layer.append("svg");
		contourGroup = svg.append("g")
			.attr("class", "contourGroup")
			.attr("opacity",.8);
		var overlayProjection = this.getProjection();

		// turn google map projection into d3 projection
		var googleMapProjection = d3.geoTransform({point: function(x, y) {
			d = overlayProjection.fromLatLngToDivPixel( new google.maps.LatLng(y, x) );
			this.stream.point(d.x + 4000, d.y + 4000);
		}});
		pathproj = d3.geoPath().projection(googleMapProjection);

		var surfData = {width:250, height:250};
            surfDataProjection = d3.geoTransform({point: function(i,j) {
                x = lng_low+j/surfData.width*(lng_high-lng_low);
                y = lat_low+i/surfData.height*(lat_high - lat_low);
				d = overlayProjection.fromLatLngToDivPixel( new google.maps.LatLng(y, x) );
				this.stream.point(d.x + 4000, d.y + 4000);
			}});
	}
	overlay.setMap(map);

	// drawing routine
	overlay.draw = function () {
		this.update();
	};

	overlay.update = function() {
		/*
		contourGroup.selectAll(".mypoly")
			.attr("d", pathproj)
		*/
		contourGroup.selectAll(".mypoly")
			.attr("d", d3.geoPath().projection(surfDataProjection) )
	}
	mult.map = map;

	/*
	mult.setGeojson = function(json) {
		contourGroup.selectAll(".mypoly")
			.attr("class","remove")
			.remove();
		contourGroup.selectAll(".mypoly")
			.data(json.features)
			.enter()
			.append("path")
			.attr("d", pathproj)
			.attr("class", "mypoly")
			.attr("fill-opacity", 0.5)
            .attr("z-index", function(d) {
                return Math.round(d.levelSetValue*100);
            })
            .attr("fill", function(d) {
                return depthColors(d.levelSetValue);
            });
	}
	*/
	mult.setContourData = function(surfData) {

		contData = d3.contours()
			.size([surfData.width, surfData.height])
			.thresholds(depthBins)
			//.thresholds([1,2,3,4,5])
			(surfData.values);


		// var i0 = d3.interpolateHsvLong(d3.hsv(210, .5, 1), d3.hsv(235, 1, 0.25));
		// //var i0 = d3.interpolateHsvLong(d3.hsv(0, .3, 1), d3.hsv(0, 1, .4));
		// var color = d3.scaleSequential(i0).domain([0, 10]);

		contourGroup.selectAll(".mypoly")
			.attr("class","remove")
			.remove();
		contourGroup.selectAll(".mypoly")
			.data(contData)
			.enter()
			.append("path")
			.attr("d", d3.geoPath().projection(surfDataProjection))
			.attr("class", "mypoly")
			.attr("fill", function(d) { return depthColors(d.value); });
		}

	return mult;
}


//individualView.addEventListener("click",function() { individualView.style.display ="none"; });
</script>

</body>
</html>
