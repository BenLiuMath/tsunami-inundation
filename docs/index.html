<!DOCTYPE HTML>
<html xml:lang="en" lang="en">
<head>
	<title>Tsunami Hazard Visualizer</title>
	<style>

	* { padding: 0; margin: 0; }

	body {
		margin: 0 auto 0 auto;
		padding: 0;
		max-width: 100%;
		font-family: "Avenir", "Avenir Next", Helvetica Neue, Arial;
		font-size: 0.95em;
	}

	.content {
		width:60%;
		min-width:800px;
		margin:0 auto;
	}

	h1, h2, h3, h4, h5 {
		color: #492a7c;
		background-color: inherit;
		font-weight: normal;
		padding: 0 0 5px 0;
		margin: 15px 0 0 0;
		border: none;
		clear: right;
	}
	h1 { font-size: 20pt; margin:  5px 0 10px 0; line-height: 28px; }
	h2 { font-size: 14pt; margin: 30px 0 15px 0; letter-spacing: 0.01em; border-bottom: 1px solid #ccc;  line-height: 20px;}
	h3 { font-size: 13pt; }
	h4 { font-size: 12pt; }
	h5 { font-size: 10pt; }
	p { margin: 0 0 10px 0; }

	.articletext {
		font-family: "Avenir Next";
		/* font-size: 1.8em; */
		padding: 10px;
		line-height:1.5em;
		text-align:justify;
	}

	#flipbookvis {
		position:relative;
		top:0;
		left:0;
		width:100%;
		height:550px;
		padding:0px;
		margin:0px;
		margin:0 auto;
	}

	#flipbookmap {
		position:absolute;
		top:0px;
		left:0px;
		width:50%;
		height:100%;
		border: 1px solid #ccc;
		display:block;
	}

	#flipbooklegendcomparison {
		position:absolute;
		display: block;
		background:yellow;
		left:50%;
		width:20%;
		min-width:100px;
		text-align:right;
	}

	#viscontainer {
		position:relative;
		top:0;
		left:0;
		width:100%;
		height:600px;
		padding:0px;
		margin:0px;
	}

	#fieldtabs {
		margin:0px;
		height:40px;
		display:inline-block;
		z-index: 5; /* Brings buttons in front of map */
		background-color: #FFFFFF;
		text-align: center;
		overflow: hidden;
		border: 1px solid #ccc;
		background-color: #f1f1f1;
	}

	#tabbedcontent {
		position:relative;
		top:0px;
		left:0px;
		vertical-align: top;
		width:100%;
		height:calc(100% - 40px);
		//border: 1px solid #ccc;
	}
	#map {
		position:absolute;
		top:0px;
		left:0px;
		width:40%;
		height:calc(100% - 60px);
		display:block;
	}

	#slidecontainer {
		position: absolute;
		bottom:0px;
		left:2%;
		width:36%;
		z-index: 5; /* Brings slider in front of map */
	}

	.slider {
		width: 100%;
	}

	/*
	input[type=range]::-webkit-slider-runnable-track {
		width: 100%;
		height: 8.4px;
		cursor: pointer;
		box-shadow: 0px 0px 0px #000000, 0px 0px 0px #0d0d0d;
		background: rgb(211,211,211);
	}
	*/


	#individualfocus {
		position:absolute;
		top:0px;
		right:0%;
		width:60%;
		height:100%;
		display:block;
		padding:0;
		margin:0;
	}

	#smallmultiplescontainer {
		position:absolute;
		top:0;
		left:0;
		width:100%;
		height:100%;
	}

	#colorlegend {
		position:relative;
		top:00px;
		left: 100%;
		width:50px;
		height:400px;
		background: rgb(255,255,255,.7);
		/* border:1px solid black; */
		display:inline-block;
	}

	#flipcolorlegend {
		position:relative;
		left: 80%;
		background: rgb(255,255,255,.7);
		/* border:1px solid black; */
		display:block;
	}

	#resetbutton {
	    position: absolute;
	    top:-38px;
	    left: 290px;
		width:80px;
	    z-index: 5; /* Brings buttons in front of map */
	    background-color: #FFFFFF;
	    text-align: center;
	    padding-left: 5px;
	}
	#resetbutton input {
		width:100%;
	}


	.SvgOverlay {
		position: relative;
		width: 100%;
		height: 100%;
	}
	.SvgOverlay svg {
		position: absolute;
		top: -4000px;
		left: -4000px;
		width: 8000px;
		height: 8000px;
		opacity: 1.0;
	}
	.SvgOverlay path {
		stroke: black;
		stroke-width: 0px;
		//fill-opacity: 0.3;
	}


	.backdrop {
		position:absolute; top:0px; left:0px;
		width:100%;
		height:100%;
		opacity:0.8;
	}

	.MapBounds {
		color:red;
	}

	.smallmultiple {
		margin:1% 1% 1% 1%;
		padding:0;
		width:30%;
		height:46%;
		border:1px solid black;
		display:inline-block;
	}

	.simLabel {
		padding-top:5px;
		height:1.5em;
		text-align:center;
		background: rgb(255,255,255,.5);
	}

	.smallMultipleMap {
		margin:none;
		display:block;
		width: 100%;
		height: calc(100% - 1.5em - 5px);
		padding: 0px;
	}


	#supplemental {
		position:relative;
		margin-top:20px;
		font-family: "Avenir Next";
		/* font-size: 1.8em; */
	}

</style>

<style>
/* Style the tab */


/* Style the buttons that are used to open the tab content */
#fieldtabs button {
    background-color: inherit;
    border: none;
    outline: none;
	margin:none;
    cursor: pointer;
	padding:0 1em 0 1em;
	height:100%;
    transition: 0.3s;
}

/* Change background color of buttons on hover */
#fieldtabs button:hover {
    background-color: #ddd;
}

/* Create an active/current tablink class */
#fieldtabs button.active {
    background-color: #ccc;
}


		#calcContainer {
			width:50%;
			border:1px solid black;
			margin:0 auto;
			font-size:120%;
			padding:5px 20px;
			text-align:center;
		}
		#calcContainer input {
			font-size:110%;
			text-align:center;
		}

</style>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCyJ45cnv6HeZr69pu26XSsUF-OMC6cNRU"></script>
<script type="text/javascript" src="https://d3js.org/d3.v4.min.js" ></script>
<script src="https://d3js.org/d3-contour.v1.min.js"></script>
<script src="https://d3js.org/d3-hsv.v0.1.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.js"></script>

</head>
<body>
<div class="content">

	<div class="articletext">

		<h1>Estimating the Risks of Tsunamis</h1>

		<!-- <p>On the West Coast of the United States, these earthquakes come in two flavors.
			First, there are the earthquakes occuring in the <strong>Cascadia Subduction Zone</strong>, which are referred to as <strong>near-field</strong> events
			(since they occur relatively nearby). Near-field events have a limited geographic area in which they can occur, so they occur relatively frequently.
			Since they originate nearby, however, the tsunamis they trigger can be extremely damaging.</p>

			<p>The opposite of near-field events are <strong>far-field</strong> events. These can occur in a much broader range of locations, and hence are
				much more common. However, the greater distance of the West Coast from the earthquake's origin means that the resulting tsunamis often
			have less severe effects (on us, at least).</p>

				 <p>Let's look at an example: Crescent City, CA. </p>

				 <p><a href="https://en.wikipedia.org/wiki/Crescent_City,_California">Crescent City</a>
					 lies in the northenmost part of California, about 20 miles south of Oregon and along the coast.
					 It has a history of damage due to tsunamis, including the 1964 Alaska earthquakes and the 2011 Tohoku earthquake.
					 Several blocks of Crescent's City's downtown area were destroyed by the 1964 tsunami, and are now covered by
					 the Beach Front Park you see along the waterfront in the maps below.
				 </p> -->

		<!-- <p>Choose
			<a href="#supplemental">near-field</a>
			near-field
			</span>
			(Cascadia) or <a href="#supplemental">far-field</a> events.
			A single-click on the large map (aggregated inundation levels) will focus the small maps (corresponding to different simulations) on that spot.
		</p> -->

		<p>
			At 5:36 p.m. AST On March 27, 1964 600 miles of fault near Anchorage, Alaska ruptured, resulting in the second most powerful earthquake ever recorded. Roughly four hours later the first of four tsunami waves caused by the quake reached Crescent City, California. The first wave merely resulted in localized flooding. The second and third were smaller than the first and had little effect. The fourth wave, however, struck the city with a height of about six meters (20 feet) after having pulled most of the water from the harbor. After the dust had settled the damage was tallied: over 100 injured; 12 confirmed dead; 289 buildings destroyed; 100 cars and 25 large fishing ships crushed; 60 blocks inundated with 30 beyond repair.
		</p>

		<p>
			Due to its offshore geography, Crescent City, and especially its harbor, are unusually susceptible to tsunamis. Since 1964 the city has sustained damage from a number of additional earthquakes. The 2005 Eureka earthquake caused the entire city to be evacuated. In November 2006, an earthquake by the Kuril Islands in the western Pacific created a tsunami which damaged multiple docks and boats. The 9.0 earthquake that struck Japan on March 11, 2011 produced a tsunami which destroyed 35 boats and damaged the harbor severely.
		</p>

		<p>
			To improve Crescent City’s preparedness going forward, researchers seek to better understand the impact of tsunamis arising from a number of possible seismic events. One approach is to use <strong>numerical simulations</strong> to predict tsunami damage. The process of modeling a tsunami begins with the specification of the seismic event causing the tsunami. This entails stipulating a slip pattern, which measures where and to what degree the ocean floor moves in during the earthquake, and the location of the earthquake. The slip pattern determines how water is displaced, leading to the initial formation of the tsunami. The virtual tsunami is then tracked from the epicenter of the seismic event, across the ocean, and to the Crescent City harbor to determine the degree of inland flooding, known as inundation. The inundation levels predicted by several simulations, each with different seismic events, are shown below.
		</p>

	</div>

	<div id="flipbookvis">
		<div id="flipbookmap"></div>
		<div id="flipbooklegendcomparison" style="vertical-align:bottom; background:none; height:100%; ">
			<img src="person.png" id="personcomparepicture" style="height:5px; position:absolute; bottom:0px; right:50px; ">
			<div id="flipcolorlegend" style="display:inline-block; position:absolute; bottom:0px; "></div>
		</div>
	</div>

	<div class="articletext">
		<p>
			Notice that the simulated tsunamis have vastly different impacts on Crescent City in terms of flooding. In order to understand the “overall” tsunami risk posed to the city, we should take into account the characteristics of each.
		</p>

		<p>
			The tsunamis which affect Crescent City are caused by earthquakes which come in two flavors. First, there are the earthquakes originating in the <a href="https://en.wikipedia.org/wiki/Cascadia_subduction_zone">Cascadia Subduction Zone</a>, which are referred to as <strong>near-field events</strong> (since they occur relatively nearby). Since near-field events have a limited geographic area in which they can occur and due to the nature of the local tectonic plates, they occur relatively infrequently. According to the simulations they also tend to be extremely damaging. And because they originate nearby, they reach Crescent City quickly, leaving inhabitants less time to evacuate.
		</p>

		<p>
			The complement of near-field events are called <strong>far-field events</strong>. These can occur in a much broader range of locations, and hence are much more common. However, the greater distance of the West Coast from the earthquake's origin means that the resulting tsunamis usually have less severe effects. The far-field events in our simulations come from <a href="https://en.wikipedia.org/wiki/Aleutian_Trench">Alaska and the Aleutian Islands</a>, <a href="https://en.wikipedia.org/wiki/Peru%E2%80%93Chile_Trench">Southern Chile</a>, <a href="https://en.wikipedia.org/wiki/Kuril%E2%80%93Kamchatka_Trench">Kamchatka</a>, <a href="https://en.wikipedia.org/wiki/Kuril%E2%80%93Kamchatka_Trench">the Kuril Islands</a>, and <a href="https://en.wikipedia.org/wiki/Japan_Trench">Tohoku, Japan</a>.
		</p>

		<p>
			As described above, near- and far-field events differ in terms of how likely they are to take place. But individual simulated events from the same (or close) locations can also differ in how likely they are to occur, based on properties of the tectonic plates in that location. Associated with each earthquake is its <strong>annual probability</strong> of occurrence. The annual probability of an event describes the odds that the event will happen sometime in a single year. For example, an event with annual probability 1/100 has a 1 in 100 chance of occuring any given year. It does not, however, guarantee that the event will happen in the next 100 years (more on that later). These probabilities are usually not known exactly, and are instead estimated by experts.
		</p>
		<p>
			Given that we do not know in advance what kind of seismic event will happen next, we would like to combine the information from all the simulations into one aggregate inundation map. We start by picking an annual probability, <em>p</em>, in which we are interested. For each point in a region of the map we then use the results of all the simulations to figure out the maximum amount of flooding that the simulations predict could occur with probability at least <em>p</em>. The result is a map which shows the “worst-case” amount of flooding one would expect to occur with annual probability <em>p</em>. We can vary <em>p</em> to produce more such maps and get an idea of how likely different levels of inundation might be.
		</p>
		<p>
			We show a collection of these “inundation maps” below. You can modify the probability using the slider. You can also see how the map changes when you restrict to just near-field or just far-field events using different tabs. Some of the individual simulations that informed the inundation map are shown on the right. If you are interested in a particular point, you can click it in the large map and the small maps will shift focus to your point.

		</p>

		<div>
			<svg width="300" height="200" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">
			 <!-- Created with SVG-edit - http://svg-edit.googlecode.com/ -->
			 <g>
			  <title>Layer 1</title>
			  <path stroke="brown" id="svg_2" d="m99.65332,193c0,0 67.16046,-25 98.82182,-78c31.66136,-53 100.74069,-59 100.74069,-59" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" fill="none"/>
			  <text style="cursor: move;" xml:space="preserve" text-anchor="middle" font-family="serif" font-size="12" id="svg_12" y="69.01562" x="18.7969" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" stroke="#000000" fill="#000000">ζ =</text>
			  <path id="svg_4" d="m3.3125,98.7627c0,0 94,17 149,-59c55,-76 131,17 131,17" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke="blue" fill="none"/>
			  <line stroke="#000000" id="svg_5" y2="103" x2="206.69044" y1="103" x1="1" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" fill="none"/>
			  <line stroke="#000000" id="svg_9" y2="190" x2="107" y1="103" x1="107" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" fill="none"/>
			  <line stroke="#000000" id="svg_10" y2="103" x2="175" y1="19" x1="175" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" fill="none"/>
			  <line stroke="#000000" id="svg_11" y2="73" x2="243" y1="23" x1="243" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" fill="none"/>
			  <line id="svg_1" y2="110" x2="103" y1="103" x1="107" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke="#000000" fill="none"/>
			  <line id="svg_6" y2="110" x2="111" y1="103" x1="107" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke="#000000" fill="none"/>
			  <line id="svg_7" y2="183" x2="103" y1="190" x1="107" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke="#000000" fill="none"/>
			  <line id="svg_13" y2="183" x2="111" y1="190" x1="107" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke="#000000" fill="none"/>
			  <line stroke="#000000" id="svg_14" y2="96" x2="171" y1="103" x1="175" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" fill="none"/>
			  <line id="svg_16" y2="66" x2="247" y1="73" x1="243" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke="#000000" fill="none"/>
			  <line id="svg_17" y2="30" x2="239" y1="23" x1="243" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke="#000000" fill="none"/>
			  <line id="svg_19" y2="30" x2="247" y1="23" x1="243" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke="#000000" fill="none"/>
			  <line stroke="#000000" id="svg_21" y2="96" x2="179" y1="103" x1="175" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" fill="none"/>
			  <line id="svg_22" y2="26" x2="171" y1="19" x1="175" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" stroke="#000000" fill="none"/>
			  <line id="svg_23" y2="26" x2="179" y1="19" x1="175" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" stroke="#000000" fill="none"/>
			  <line id="svg_25" y2="66" x2="239" y1="73" x1="243" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="null" stroke="#000000" fill="none"/>
			  <text stroke="#000000" xml:space="preserve" text-anchor="middle" font-family="serif" font-size="24" id="svg_3" y="14.3125" x="259.40627" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000"/>
			  <text style="cursor: move;" fill="#000000" stroke="#000000" stroke-width="0" stroke-dasharray="null" stroke-linejoin="null" stroke-linecap="null" x="231.45706" y="51.33204" id="svg_8" font-size="12" font-family="serif" text-anchor="middle" xml:space="preserve">ζ</text>
			  <text fill="#000000" stroke="#000000" stroke-width="0" stroke-dasharray="null" stroke-linejoin="null" stroke-linecap="null" x="260.6719" y="96.29688" id="svg_15" font-size="12" font-family="serif" text-anchor="middle" xml:space="preserve">B &gt; 0 (onshore)</text>
			  <text fill="#000000" stroke="#000000" stroke-width="0" stroke-dasharray="null" stroke-linejoin="null" stroke-linecap="null" x="165.75002" y="191.21876" id="svg_18" font-size="12" font-family="serif" text-anchor="middle" xml:space="preserve">B &lt; 0 (offshore)</text>
			  <text style="cursor: move;" fill="#000000" stroke="#000000" stroke-width="0" stroke-dasharray="null" stroke-linejoin="null" stroke-linecap="null" x="94.66407" y="152.47657" id="svg_20" font-size="12" font-family="serif" text-anchor="middle" xml:space="preserve">-B</text>
			  <text id="svg_24" fill="#000000" stroke="#000000" stroke-width="0" stroke-dasharray="null" stroke-linejoin="null" stroke-linecap="null" x="165.85159" y="68.76758" font-size="12" font-family="serif" text-anchor="middle" xml:space="preserve">ζ</text>
			  <text stroke="#000000" transform="matrix(1,0,0,2.6099999248981476,0,-80.91499642562121) " xml:space="preserve" text-anchor="middle" font-family="serif" font-size="12" id="svg_27" y="59.40354" x="32.06838" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" fill="#000000">{</text>
			  <text style="cursor: move;" xml:space="preserve" text-anchor="middle" font-family="serif" font-size="12" id="svg_28" y="61.25587" x="71.44338" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" stroke="#000000" fill="#000000">h        if B &gt; 0,</text>
			  <text xml:space="preserve" text-anchor="middle" font-family="serif" font-size="12" id="svg_29" y="76.44337" x="72.56838" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" stroke="#000000" fill="#000000">h + B if B &lt; 0.</text>
			  <text xml:space="preserve" text-anchor="middle" font-family="serif" font-size="12" id="svg_31" y="115.81837" x="47.25587" stroke-linecap="null" stroke-linejoin="null" stroke-dasharray="null" stroke-width="0" stroke="#000000" fill="#000000">Mean High-Water</text>
			 </g>
			</svg>
		</div>

	</div>


	<div id="viscontainer">
		<!-- Buttons for near- and far-field events -->
		<div id="fieldtabs">
			<button class="tablinks" id="switchEvents_near" value="near">Near-field</button>
			<button class="tablinks" id="switchEvents_far" value="far">Far-field</button>
			<button class="tablinks" id="switchEvents_both" value="both">Near- and Far-field</button>
		</div>

		<div id="tabbedcontent">
			<div id="map"></div>
			<div id="colorlegend"></div>
			<div id="individualfocus">
				<div class="backdrop"></div>
				<div id="smallmultiplescontainer"></div>
			</div>


			<!-- Button to reset view -->
			<div id="resetbutton">
				<input id="resetView" type="button" value="Reset View">
			</div>

			<!-- Slider for probability -->
			<div id="slidecontainer">
				<input type="range" min="0" max="6" step="1" class="slider" id="probabilitySlider" list="tickmark">
				<datalist id="tickmark">
					<option label="1/50">0</option>
					<option label="1/100">1</option>
					<option label="1/200">2</option>
					<option label="1/500">3</option>
					<option label="1/1000">4</option>
					<option label="1/5000">5</option>
					<option label="1/10000">6</option>
				</datalist>
				<output id="output" for="probabilitySlider">Selected annual probability: 1 in 500</output> <!-- Just to display selected value -->
			</div>
		</div>
	</div>

	<script>
		function updateCalc() {
			var annualRecur = parseInt(document.probcalc.calc_annualRecurrence.value);
			var annualProb = 1.0/annualRecur;
			var numYears = parseInt(document.probcalc.calc_numYears.value);

			var outProb = 1.0 - Math.pow(1.0 - annualProb, numYears);

			var outField = document.getElementById("outputProbability");
			//outField.innerText = `Over ${numYears} years, an event with annual chance of occurence of 1 out of ${annualRecur} has a ${Math.round(outProb*100)} of occurring.`; //+"%";
			//outField.innerText = `${Math.round(outProb*1000)/10}%`;

			outProb = outProb*100;
			outField.innerText = outProb.toPrecision(3)+"%";
		}
		document.body.onload=updateCalc;
	</script>
	<div class="articletext">
		<div id="calcContainer">
			<form name="probcalc">
			Over
			<input type="number" name="calc_numYears" min="1" max="100" step="1" value="30" onChange="updateCalc(); " onClick="updateCalc(); " style="width:2.5em; ">
			 years, an event with an annual chance of <br/> occurrence of 1 out of
			<input type="number" name="calc_annualRecurrence" min="100" max="10000" step="100" value="500" onChange="updateCalc(); " onClick="updateCalc(); " style="width:3.5em; ">
			 happens with probability <span id="outputProbability" style="font-weight:bold; ">--%</span>.

			</table>
			</form>
		</div>
	</div>


	<div id="supplemental">
		<h1>Supplementary Material</h1>
		<p>
			If you are curious about the technical details behind the tsunami simulations, the full report can be found <a href="https://digital.lib.washington.edu/researchworks/handle/1773/25916">here.</a>
		</p>
		<p>
			One of the researchers involved in the project, Randy LeVeque, has a set of Jupyter notebooks describing the process of creating inundation maps on his <a href="https://github.com/rjleveque/ptha_tutorial">Github page</a>.
		</p>
</div>

<div id="supplemental">
			<h1>Acknowledgements</h1>
			<p>The <a href="https://commons.wikimedia.org/wiki/File:Black_star.png">black star marker</a> in the maps
				comes from ANGELUS on Wikipedia Commons, and is licensed under the Creative Commons license.</p>

	</div>

</div>
<!-- Load in the simulation data and inundation maps -->
<script src="data/simulation_data.js"></script>
<script src="data/inundation_maps.js"></script>


<!-- Styled map specifications -->
<script>
var styledMapType = new google.maps.StyledMapType(
	[
  {
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#f5f5f5"
      }
    ]
  },
  {
    "elementType": "labels.icon",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#616161"
      }
    ]
  },
  {
    "elementType": "labels.text.stroke",
    "stylers": [
      {
        "color": "#f5f5f5"
      }
    ]
  },
  {
    "featureType": "administrative.land_parcel",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#bdbdbd"
      }
    ]
  },
  {
    "featureType": "poi",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#eeeeee"
      }
    ]
  },
  {
    "featureType": "poi",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#757575"
      }
    ]
  },
  {
    "featureType": "poi.park",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#e5e5e5"
      }
    ]
  },
  {
    "featureType": "poi.park",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#9e9e9e"
      }
    ]
  },
  {
    "featureType": "road",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#ffffff"
      }
    ]
  },
  {
    "featureType": "road.arterial",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#757575"
      }
    ]
  },
  {
    "featureType": "road.highway",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#dadada"
      }
    ]
  },
  {
    "featureType": "road.highway",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#616161"
      }
    ]
  },
  {
    "featureType": "road.local",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#9e9e9e"
      }
    ]
  },
  {
    "featureType": "transit.line",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#e5e5e5"
      }
    ]
  },
  {
    "featureType": "transit.station",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#eeeeee"
      }
    ]
  },
  {
    "featureType": "water",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#c9c9c9"
      }
    ]
  },
  {
    "featureType": "water",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#9e9e9e"
      }
    ]
  }
],{name: 'Styled Map'});
</script>

<!-- Make the map!  -->
<script>
	function shuffle(a) {
		var j, x, i;
		for (i = a.length - 1; i > 0; i--) {
			j = Math.floor(Math.random() * (i + 1));
			x = a[i];
			a[i] = a[j];
			a[j] = x;
		}
		return a;
	}
	function clamp(a,min,max) {
		return Math.min(Math.max(a,min),max);
	}

	var cityCenter = {'x':-124.2026, 'y':41.7558};
	var individualView = document.getElementById("individualfocus");

	var lng_low = 235.79781-360;
	var lng_high = 235.82087-360;
	var lat_low = 41.739671;
	var lat_high = 41.762726;


	var mults = []; // array of small multiples
	var markers = []; // array of markers currently on the maps

	// // Color scheme for the inundation levels
	// // var i0 = d3.interpolateHsvLong(d3.hsv(120, 1, 0.65), d3.hsv(10, 1, 0.90));
	// // var depthColors = d3.scaleSequential(i0).domain([0, 5]);
	var i0 = d3.interpolateCool;
	function interpolateReverse(t){
		return i0(1-t);   // assumes [0,1] range
	}
	var depthColors = d3.scaleSequential(interpolateReverse).domain([1.5,12]);
	var depthBins = [1.5,3.0,4.5,6.0,7.5,9.0,10.5,12.0];

	flipBookMain();
	function flipBookMain() {
		// google map background
		var map = new google.maps.Map(document.getElementById('flipbookmap'), {
			center: {lat:(cityCenter.y-0.005), lng:(cityCenter.x+.0125)},
			zoom: 14,
			// styles:[{"stylers": [{"lightness": 100}]}],
			styles:[
				{
					"featureType": "all",
					"stylers": [{"color": "#C0C0C0"}]
				}
			],
			scrollwheel: false,
			mapTypeControl: true,
			streetViewControl: false,
			fullscreenControl: false,
			mapTypeControlOptions: {
				//mapTypeIds: ['styled_map']
				mapTypeIds: []}
		});

		map.mapTypes.set('styled_map', styledMapType);
        map.setMapTypeId('styled_map');

				// add bounding box
				var eps = 0.00005;
				var rectangle = new google.maps.Rectangle({
		          strokeColor: 'black',
		          strokeOpacity: 0.8,
		          strokeWeight: 2,
		          fillColor: 'transparent',
		          // fillOpacity: 0.0,
							clickable: false,
		          map: map,
		          bounds: {
		            north: lat_high+eps,
		            south: lat_low-eps,
		            east: lng_high+eps,
		            west: lng_low-2*eps}
		          }
						);

		// overlay geojson multipolygons on map
		var overlay = new google.maps.OverlayView();

		var contourGroup, svg, pathproj, surfDataProjection;
		overlay.onAdd = function () {
			var layer = d3.select(this.getPanes().overlayLayer)
				.append("div")
				.attr("class", "SvgOverlay");
			svg = layer.append("svg");
			contourGroup = svg.append("g")
				.attr("class", "contourGroup")
				.attr("opacity",.8);
			var overlayProjection = this.getProjection();

			// turn google map projection into d3 projection
			var googleMapProjection = d3.geoTransform({point: function(x, y) {
				d = overlayProjection.fromLatLngToDivPixel( new google.maps.LatLng(y, x) );
				this.stream.point(d.x + 4000, d.y + 4000);
			}});
			pathproj = d3.geoPath().projection(googleMapProjection);

			var surfData = {width:250, height:250};
            surfDataProjection = d3.geoTransform({point: function(i,j) {
                x = lng_low+j/surfData.width*(lng_high-lng_low);
                y = lat_low+i/surfData.height*(lat_high - lat_low);
				d = overlayProjection.fromLatLngToDivPixel( new google.maps.LatLng(y, x) );
				this.stream.point(d.x + 4000, d.y + 4000);
			}});

			flipBook();
			setInterval(flipBook, 3000);
		}
		overlay.setMap(map);

		overlay.draw = function () {
			this.update();
		}
		overlay.update = function() {
			svg.selectAll(".mypoly")
				.attr("d", d3.geoPath().projection(surfDataProjection) )
		}

		var tsunamiEvents = all_events;
		shuffle(tsunamiEvents);
		var flipInd = 0;
		function flipBook() {
			var surfData = tsunamiEvents[flipInd].eta_data;
			flipInd = (flipInd+1)%tsunamiEvents.length;

			var contourContainer = svg.append("g");
			contourContainer.attr("opacity",0)
				.transition()
				.ease(d3.easeSinInOut)
				.duration(500)
				.attr("opacity",0.8)
				.transition()
				.delay(2000)
				.ease(d3.easeSinInOut)
				.duration(500)
				.attr("opacity",0)
				.remove();

			contData = d3.contours()
					.size([surfData.width, surfData.height])
					.thresholds(depthBins)
					//.thresholds([1,2,3,4,5])
					(surfData.values);

			contourContainer.selectAll(".mypoly")
				.data(contData)
				.enter()
				.append("path")
				.attr("d", d3.geoPath().projection(surfDataProjection))
				.attr("class", "mypoly")
                .attr("fill", function(d) { return depthColors(d.value); });
		}
	}


	main();
	function main() {
		// initialize with near-field data
		var tsunamiEvents = near_events;
		var hazard_maps = eta_ps_near;

		// google map background
		var map = new google.maps.Map(document.getElementById('map'), {
			center: {lat:(cityCenter.y-0.005), lng:(cityCenter.x+.0125)},
			zoom: 14,
			// styles:[{"stylers": [{"lightness": 100}]}],
			styles:[
				{
					"featureType": "all",
					"stylers": [{"color": "#C0C0C0"}]
				}
			],
			scrollwheel: false,
			mapTypeControl: true,
			streetViewControl: false,
			fullscreenControl: false,
			mapTypeControlOptions: {
				//mapTypeIds: ['styled_map']
				mapTypeIds: []}
		});

		// add bounding box
		var eps = 0.00005;
		var rectangle = new google.maps.Rectangle({
					strokeColor: 'black',
					strokeOpacity: 0.8,
					strokeWeight: 2,
					fillColor: 'transparent',
					clickable: false,
					// fillOpacity: 0.0,
					map: map,
					bounds: {
						north: lat_high+eps,
						south: lat_low-eps,
						east: lng_high+eps,
						west: lng_low-2*eps}
					}
				);

		function focusArea(e) {
			//map.panTo(e.latLng);
			//map.setZoom(15);
			//latlngJSON = e.latLng.toJSON();
			var latLng = e.latLng.toJSON();

			var lat = latLng.lat;
			var lng = latLng.lng;
			//if (lat > lat_high || lat < lat_low || lng < lng_low || lng > lng_high) return;
			latLng.lat = clamp(lat,lat_low, lat_high);
			latLng.lng = clamp(lng,lng_low, lng_high);

			individualView.style.display = "block";
			panMultiples(latLng);
			deleteMarkers();
			addMarker(latLng, map);
			addMarkersMultiples(latLng);
          	// map.setCenter(marker.getPosition());
        }

		// zoom in and recenter when user clicks on a point
		map.addListener('click', focusArea);

		map.mapTypes.set('styled_map', styledMapType);
        map.setMapTypeId('styled_map');

		// overlay geojson multipolygons on map
		var overlay = new google.maps.OverlayView();

		var contourGroup, svg, pathproj, surfDataProjection;
		overlay.onAdd = function () {
			var layer = d3.select(this.getPanes().overlayLayer)
				.append("div")
				.attr("class", "SvgOverlay");
			svg = layer.append("svg");
			contourGroup = svg.append("g")
				.attr("class", "contourGroup")
				.attr("opacity",.8);
			var overlayProjection = this.getProjection();

			// turn google map projection into d3 projection
			var googleMapProjection = d3.geoTransform({point: function(x, y) {
				d = overlayProjection.fromLatLngToDivPixel( new google.maps.LatLng(y, x) );
				this.stream.point(d.x + 4000, d.y + 4000);
			}});
			pathproj = d3.geoPath().projection(googleMapProjection);

			var surfData = {width:250, height:250};
            surfDataProjection = d3.geoTransform({point: function(i,j) {
                x = lng_low+j/surfData.width*(lng_high-lng_low);
                y = lat_low+i/surfData.height*(lat_high - lat_low);
				d = overlayProjection.fromLatLngToDivPixel( new google.maps.LatLng(y, x) );
				this.stream.point(d.x + 4000, d.y + 4000);
			}});
		}
		overlay.setMap(map);

		overlay.draw = function () {
			this.update();
		}
		overlay.update = function() {
			contourGroup.selectAll(".mypoly")
				.attr("d", d3.geoPath().projection(surfDataProjection) )
		}


		function switchEventType(ptype) {
			var i, tabcontent, tablinks;

			// Get all elements with class="tablinks" and remove the class "active"
			tablinks = document.getElementsByClassName("tablinks");
			for (i = 0; i < tablinks.length; i++) {
				tablinks[i].className = tablinks[i].className.replace(" active", "");
			}

			// Show the current tab, and add an "active" class to the button that opened the tab
			//evt.currentTarget.className += " active";
			document.getElementById("switchEvents_"+ptype).className += " active";

			switch(ptype) {
				case "far":
					tsunamiEvents = far_events;
					hazard_maps = eta_ps_far;
				break;
				case "near":
					tsunamiEvents = near_events;
					hazard_maps = eta_ps_near;
				break;
				default:
					tsunamiEvents = all_events;
					hazard_maps = eta_ps_all;
			}
			initPlots();
		}

		function attachButtons() {
			var types = ["near","far","both"];
			for(var ii=0; ii<types.length; ii++) {
				var mybutton = document.getElementById("switchEvents_"+types[ii]);
				function buttonfunc(evt) {
					switchEventType(evt.currentTarget.value);
				}
				mybutton.addEventListener("click",buttonfunc);
			}
		}
		attachButtons();

		document.getElementById("resetView")
			.addEventListener("click", function() {
				var resetLatLng = {lat:(cityCenter.y-0.005), lng:(cityCenter.x+.0125)};
				map.setCenter(resetLatLng);
				map.setZoom(14);
				deleteMarkers();
				panMultiples(resetLatLng,14);
			});


		function setContourData(surfData) {
			contData = d3.contours()
					.size([surfData.width, surfData.height])
					.thresholds(depthBins)
					//.thresholds([1,2,3,4,5])
					(surfData.values);

					contourGroup.selectAll(".mypoly")
				.attr("class","remove")
				.remove();
			contourGroup.selectAll(".mypoly")
				.data(contData)
				.enter()
				.append("path")
				.attr("d", d3.geoPath().projection(surfDataProjection))
				.attr("class", "mypoly")
                .attr("fill", function(d) { return depthColors(d.value); });
		}

		var yearlyRecurrences = [50,100,200,500,1000,5000,10000];
		// Set the contour data by specifying the yearly recurrence (inverse probability). Code searches for closest probability level to given parameter.
		function setProbLevel(yearlyRecurrence) {
			var bestind = 0;
			var closeness = 100000;
			for(var ii=0; ii<yearlyRecurrences.length; ii++) {
				var thisclose = Math.abs(yearlyRecurrences[ii]-yearlyRecurrence);
				if( Math.abs(thisclose) < closeness ) {
					bestind = ii;
					closeness = thisclose;
				}
			}
			setContourData(hazard_maps[bestind]);
		}
		function setProbLevelByIndex(ind) {
			setContourData(hazard_maps[ind]);
		}

		var outputSlider = document.getElementById("output");
		var probSlider = document.getElementById("probabilitySlider");
		probSlider.addEventListener("change",function() {
			setProbLevelByIndex(probSlider.value);
			outputSlider.value="Selected annual probability: 1 in " + pInv[probSlider.value];
		});


		function initPlots() {
			setProbLevel(1000);
			populateMultiples();
		}
		setTimeout(initPlots, 100);

		// For drawing small multiples
		var multcontainer = document.getElementById("smallmultiplescontainer");

		for(var ii=0; ii<6; ii++) {
			var mymultDiv = document.createElement("div");
				mymultDiv.classList.add("smallmultiple");
				multcontainer.appendChild(mymultDiv);
			var mymult = multMaker(mymultDiv);
			mults.push(mymult);
		}

		function populateMultiples() {

			var eventshuffle = tsunamiEvents.slice();
			shuffle(eventshuffle);

			for(var ii=0; ii<Math.min(eventshuffle.length, 6); ii++ ) {
				//mults[ii].setGeojson(CSZEvents[ii]);
				mults[ii].setContourData(eventshuffle[ii].eta_data);
				mults[ii].setLabel(eventshuffle[ii].decode);
			}
		}

		function makeLegend() {
			// draw the legend
			var topMargin = 20;
			var blockWidth = 25;
			var blockHeight = 30;

			var legWidth = 200;
			var legHeight = blockHeight*8+topMargin+10;

			var svg = d3.select("#colorlegend")
					.attr("class","legendQuant")
					.append("svg")
					.attr("width", legWidth)
					.attr("height", legHeight);

			svg.append("g")
			.attr("class", "legendSequential")
				.attr("transform",`translate(0,${topMargin})`);

			// svg.append("text")
			// // .attr("class", "legendSequential")
			// .attr("transform", "translate(0,10)")
			// .text("meters flooded");

			/*
			// maybe rotate the text 90 degrees?
			svg.append("text")
			.attr("x", 345)
			.attr("y", 32)
			.text("Meters");
			*/

			var legendSequential = d3.legendColor()
				.shapePadding(0)
				.shapeWidth(blockWidth)
				.shapeHeight(blockHeight)
				.cells(7)
				.orient("vertical")
				.ascending("true")
				.labels( () => { return "";})
				.scale(depthColors);


			var mylabels = depthBins.slice();//.push(0);
			mylabels.unshift(0);
			mylabels.reverse();
			for(var jj=0; jj<mylabels.length; jj++) {
				svg.append("text")
					.attr("transform", `translate(${blockWidth+10},${jj*blockHeight+topMargin+5})`)
					.text(mylabels[jj]);
				svg.append("line")
					.attr("x1",0)
					.attr("x2",blockWidth)
					.attr("y1",jj*blockHeight+topMargin)
					.attr("y2",jj*blockHeight+topMargin)
					.attr("stroke","black");
			}

			svg.select(".legendSequential")
				.attr("opacity",.8)
				.call(legendSequential);
		}

		function makeFlipLegend() {
			// draw the legend
			var topMargin = 20;
			var blockWidth = 25;
			var blockHeight = 65;

			var legWidth = 200;
			var legHeight = blockHeight*8+topMargin+1;

			var svg = d3.select("#flipcolorlegend")
					.attr("class","legendQuant")
					.append("svg")
					.attr("width", legWidth)
					.attr("height", legHeight);

			svg.append("g")
				.attr("class", "legendSequential")
				.attr("transform",`translate(0,${topMargin})`);

			svg.append("text")
				.attr("class", "legendSequential")
				.attr("transform", `translate(${80},320)rotate(-90)`)
				.text("meters flooded")
				.attr("font-size","16pt");

			document.getElementById("personcomparepicture").style.height = 1.764 / 1.5*blockHeight+"px";

			var legendSequential = d3.legendColor()
				.shapePadding(0)
				.shapeWidth(blockWidth)
				.shapeHeight(blockHeight)
				.cells(7)
				.orient("vertical")
				.ascending("true")
				.labels( () => { return "";})
				.scale(depthColors);

			var mylabels = depthBins.slice();//.push(0);
			mylabels.unshift(0);
			mylabels.reverse();
			for(var jj=0; jj<mylabels.length; jj++) {
				svg.append("text")
					.attr("transform", `translate(${blockWidth+10},${jj*blockHeight+topMargin})`)
					.text(mylabels[jj]);
				svg.append("line")
					.attr("x1",0)
					.attr("x2",blockWidth)
					.attr("y1",jj*blockHeight+topMargin)
					.attr("y2",jj*blockHeight+topMargin)
					.attr("stroke","black");
			}


			svg.select(".legendSequential")
				.attr("opacity",.8)
				.call(legendSequential);
		}
		makeLegend();
		makeFlipLegend();
	}


function deleteMarkers() {
	for (var i = 0; i < markers.length; i++) {
			markers[i].setMap(null);
		}
		markers = [];
}

var markerImage = 'Black_star.png';

function addMarker(latLng, map) {
	// add the new marker to the given map
	var marker = new google.maps.Marker({
		position: latLng,
		map: map,
		icon: markerImage
	});
	// record the marker
	markers.push(marker);
}

function addMarkersMultiples(latLng) {
	for(var ii=0; ii<mults.length; ii++) {
		addMarker(latLng, mults[ii].map);
	}
}

function panMultiples(latLng,zoom) {
	if(!zoom) {
		zoom = 14;
	}
	for(var ii=0; ii<mults.length; ii++) {
		mults[ii].map.setZoom(zoom);
		mults[ii].map.panTo(latLng);
	}
}


function multMaker(containerDiv) {

	var mult = {};

	var myLabel = document.createElement("div");
		myLabel.classList.add("simLabel");
		//myLabel.appendChild(document.createTextNode("label"))
		myLabel.innerText = " ";
	containerDiv.appendChild(myLabel);

	var mapContainer = document.createElement("div");
	mapContainer.classList.add("smallMultipleMap");
	containerDiv.appendChild(mapContainer);
	mult.setLabel = function(text) {
		myLabel.innerText = text;
	}

	// google map background
	var map = new google.maps.Map(mapContainer, {
		// center: new google.maps.LatLng(47.4,-120.5),
		//center: new google.maps.LatLng(41.759671,-124.20219),
		center: {lat:41.7509671, lng:-124.19219},
		zoom: 14,
		disableDoubleClickZoom:true,
		draggable: false,
		scrollwheel: false,
		panControl: false,
		styles:[{"stylers": [{"lightness": 100}]}],
		mapTypeControl: false,
		streetViewControl: false,
		fullscreenControl: false,
		zoomControl:false,
		mapTypeControlOptions: {
			mapTypeIds: ['roadmap', 'styled_map']}
	});

	map.mapTypes.set('styled_map', styledMapType);
	map.setMapTypeId('styled_map');

	// add bounding box
	var eps = 0.00005;
	var rectangle = new google.maps.Rectangle({
				strokeColor: 'black',
				strokeOpacity: 0.8,
				strokeWeight: 2,
				fillColor: 'transparent',
				// fillOpacity: 0.0,
				clickable: false,
				map: map,
				bounds: {
					north: lat_high+eps,
					south: lat_low-eps,
					east: lng_high+eps,
					west: lng_low-2*eps}
				}
			);

	// overlay geojson multipolygons on map
	var overlay = new google.maps.OverlayView();

	var contourGroup, pathproj, svg, surfDataProjection;
	overlay.onAdd = function () {
		var layer = d3.select(this.getPanes().overlayLayer)
			.append("div")
			.attr("class", "SvgOverlay");
		svg = layer.append("svg");
		contourGroup = svg.append("g")
			.attr("class", "contourGroup")
			.attr("opacity",.8);
		var overlayProjection = this.getProjection();

		// turn google map projection into d3 projection
		var googleMapProjection = d3.geoTransform({point: function(x, y) {
			d = overlayProjection.fromLatLngToDivPixel( new google.maps.LatLng(y, x) );
			this.stream.point(d.x + 4000, d.y + 4000);
		}});
		pathproj = d3.geoPath().projection(googleMapProjection);

		var surfData = {width:250, height:250};
            surfDataProjection = d3.geoTransform({point: function(i,j) {
                x = lng_low+j/surfData.width*(lng_high-lng_low);
                y = lat_low+i/surfData.height*(lat_high - lat_low);
				d = overlayProjection.fromLatLngToDivPixel( new google.maps.LatLng(y, x) );
				this.stream.point(d.x + 4000, d.y + 4000);
			}});
	}
	overlay.setMap(map);

	// drawing routine
	overlay.draw = function () {
		this.update();
	};

	overlay.update = function() {
		/*
		contourGroup.selectAll(".mypoly")
			.attr("d", pathproj)
		*/
		contourGroup.selectAll(".mypoly")
			.attr("d", d3.geoPath().projection(surfDataProjection) )
	}
	mult.map = map;

	/*
	mult.setGeojson = function(json) {
		contourGroup.selectAll(".mypoly")
			.attr("class","remove")
			.remove();
		contourGroup.selectAll(".mypoly")
			.data(json.features)
			.enter()
			.append("path")
			.attr("d", pathproj)
			.attr("class", "mypoly")
			.attr("fill-opacity", 0.5)
            .attr("z-index", function(d) {
                return Math.round(d.levelSetValue*100);
            })
            .attr("fill", function(d) {
                return depthColors(d.levelSetValue);
            });
	}
	*/
	mult.setContourData = function(surfData) {

		contData = d3.contours()
			.size([surfData.width, surfData.height])
			.thresholds(depthBins)
			//.thresholds([1,2,3,4,5])
			(surfData.values);


		// var i0 = d3.interpolateHsvLong(d3.hsv(210, .5, 1), d3.hsv(235, 1, 0.25));
		// //var i0 = d3.interpolateHsvLong(d3.hsv(0, .3, 1), d3.hsv(0, 1, .4));
		// var color = d3.scaleSequential(i0).domain([0, 10]);

		contourGroup.selectAll(".mypoly")
			.attr("class","remove")
			.remove();
		contourGroup.selectAll(".mypoly")
			.data(contData)
			.enter()
			.append("path")
			.attr("d", d3.geoPath().projection(surfDataProjection))
			.attr("class", "mypoly")
			.attr("fill", function(d) { return depthColors(d.value); });
		}

	return mult;
}


//individualView.addEventListener("click",function() { individualView.style.display ="none"; });
</script>

</body>
</html>
